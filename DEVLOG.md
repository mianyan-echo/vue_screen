# VUE开发笔记
之前因为对前端框架的各种概念都不太清晰，现在有了一定的眉目，开始记录一些开发过程中遇到的问题
***
***
## 2021.1.12
* vue条件渲染似乎与dash.js的MediaPlayer并不兼容，在播放弹窗关闭后，通过浏览器Network监控发现player仍在get MPEG DASH的mpd与视频切片。

  最后的解决办法是在父组件中对dash_player组件的标签添加ref，然后通过$refs调用子组件的任意属性与方法，从而在弹窗关闭时可以同时重置dash播放器。
* small_window在被拖动时整体页面应该处于不可选中状态，这种状态是通过BOM实现的。
  
  即`window.onselectstart`与`window.onselect`进行选择时会触发不为`null`的它们，依据返回的bool值来判断是否可以选中，返回`false`为无法选中
* 再说说组件扩展，其实官方叫`extend`与`mixin`已经说明这个不像对象的继承，组件间也没有继承只有组合。想像python的类一样灵活重用是不可能的。

  好在vue组件间的通信方法有很多，通过组件的组合与布局还算可以比较清晰用代码的描述页面的逻辑，保证组合组件内部子组件的通信配合。
* 下一步准备用axios请求后端数据库中的MPEG DASH控制文件地址，加入echarts数据可视化

  用element ui美化一下界面，加入过渡动画
***
## 2021.1.13
* ~~vue组件的unmount似乎改成了destroy，将player的重置操作放入beforeDestroy以后也可以达到停止继续加载的目的~~（见2021.1.17）
* 想直接在vue组件中用axios请求后端的restful api，但在下手之前感觉这样一点也不灵活，所有的url都分散的放置在组件中的话既不纯粹也不好维护。
  
  所以在axios封装的基础上将rest api也模块化的封装起来，使其只对外提供现成的能表示操作含义的api接口函数。api版本与baseurl都可以模块化的更改
  
  详细的组织方法可以看rest_api的README
***
## 2021.1.14
* windows可以通过`tree /f`命令得到当前目录的目录树，在markdown中可以直接用代码段完整的显示目录树。
* 跨域问题，没想到跨域问题是这样一种形式，选用的解决方法是在前端本来的域上架一个代理，对特定的url进行匹配路由到后端服务器，解决跨域问题的过程也学了vue3.x的配置文件，等到build时可以少走一些弯路。
* 在实装rest_api库的过程中，初步接触了javascript的异步编程，对axios底层的Promise类有了比较深入的了解，只能通过`.zhen`拉起回调函数读取数据的promise链稍显死板。
* 目前对从Promise对象中取出数据还没有更好的思路，寄希望于javascript的异步编程
* 对js的变量作用域也有了新的认识，写了一段时间前端，反而对python的内部机理有些生疏了，js的let变量作用域很类似于python，都是给对象贴的标签叫做变量名，所以这两种语言做闭包都是一种效果
***
## 2021.1.15
* 在继续实装rest_api的过程中发现了一个问题,如果每个组件都包含一部分对后端的请求,那么每个组件都会变得不是那么纯粹,耦合性太强.
  
  比如对于`dash_player`与`dash_play_window`这两个组件,其在标签中传入的props之应该是MPEG DASH或HLS的源文件URL,这两个组件明显不应该与后端api服务器产生交互
* 现在因为组件还不是特别多,暂时先实现功能,**在美化开始前进行重构**
* 需要哪个组件就吧v-for放到哪个组件内，~~不知道为什么ESLint会判断在自定义组件中用v-for有错误~~（见2021.1.20），但是并不影响运行
* 现在vue前端与restful api后端的闭环交互初步完成，下一步在后端增加一些新需求的api，丰富前端界面的内容
***
## 2021.1.16
* 现在做的东西的成品应该算是一个dashboard，在思考给它增加一些对什么数据的展示
* 在装element ui的时候看了一眼package.json，发现这个项目是基于vue 2.6.11的，之前一直看的教程都是vue 3.x的，怪不得组件生命周期的名字不一样

  想尝试一下将这个项目移植到vue 3.x，会开一个新分支dev_vue3将现有的组件移植到vue3.x，希望可以积累一些经验。
***
## 2021.1.17
* 成功将项目移植到了vue3，后续将把分支改名，master会merge到与vue3开发分支，dev_echarts改名为dev_vue2并作为vue2开发分支独立开发。
* 迁移到vue3对项目整体结构影响不大，改动最多的地方为应用入口文件main.js，它由先配置vue全局属性改为了先createApp，然后在建立好的app的基础上对本app进行配置，其实这样也就说明vue3与django一样支持了独立应用这一概念。
* 也由于会先建立应用，所以导致了
  * 对应用附加的`axios`、`rest_api`等全局属性并不能在组件的setup中调用
  * 通过ref获取DOM的时候在setup内通过`context.$refs.refName`调不到任何东西
* 由于是先通过App.vue建立好了app，所以如果想让程序最大限度地按照预想的生命周期运行，那么挂载`app.mount('#app')`就一定要在main.js的末尾，也就是先创建app，再设置app，最后挂载
* 果然生命周期改名的问题是vue3从vue2的destroy改为了unmount
* 总的来说，如果不考虑使用vue3的**组合式api**，那么项目一定需要更改的地方很少，由于保留了之前的**选项式api**，基本是向下兼容的
***
## 2021.1.18
* 对页面整体应用了element plus，目前主页面和小窗组件都嵌入了element plus的组件
* 对于可拖动的小窗`dash_play_window`组件，并没有用主流的饿了么Dialog对话框做，由于Dialog的完成度太高，各项写死的逻辑限制很大
* 还掌握了一个技巧，饿了么的一些细微部分的css并没有暴露的指令和属性供开发者自定义，这时候可以在浏览器中用开发者工具去寻找对应部分在渲染好以后所用的css类选择器。然后在style中用`/deep/ 类选择器{}`控制那部分组件的样式表
* el-card组件并不能随意的通过鼠标事件移动，所以外层还是要有div来接受鼠标事件
* ~~后边准备做一下有冲突的合并分支~~（因为node_modules并没有加入组件库，所以如果进行vue2的开发就要重新install）
***
## 2021.1.19
* 大概看了一下vue的scoped机制，也就顺带明白了昨天用到的`/deep/`深度作用选择器的作用，类似于继承后的重定义，对本组件内的修改不会影响到同css类选择器的其它组件
***
## 2021.1.20
* 视频小窗最小化到底栏的功能完成了，其实是伪最小化，并没有采用动态移动vue组件的方法，只是将dash的源地址传出来，然后存到一个Set里
* 重新写了一个不能拖动带关闭按钮的dash_play_card组件，传入和传出都是dash的源地址，父组件根据传出的url删掉存储的Set中的对应url
* v-for会提示错误是因为：vue建议在使用`v-for`的同时加上`:key`，为了在绑定的序列变化时，可以更高效的就地渲染
* `v-for`在绑定序列为空的的时候不会往父组件内插入任何组件，所以如果父组件的插槽内有默认内容的话就可以显示出来
* 底部栏`footer_drawer`是用element plus的抽屉完成的,目前不尽如人意的一点是抽屉打开以后就不能控制页面内的其它元素了，原因是抽屉会加一层全屏的div，并且z-index根据页面内其它元素的最大z-index变化
* 下一步引入echarts，将摄像头与地理位置关联起来
## 2021.1.22
* javascript序列在遍历时需要选择`on`、`in`：`in`遍历`key`；`on`遍历value
* 如果父组件想要传入子组件的props是会随与后端交互等操作改变的，并不是初始值，那么需要在子组件中加入watch来监听该prop的变化
* 另外一种对组件属性延后传递做响应的方案是用组件生命周期的updated回调
* 把`echarts.init`的实例做成vue的组件属性地图的旋转会变得十分卡顿，不知道具体的原因
* 主要逻辑功能完成，后续
  * 用DataV美化界面加入动画边框，
  * 在功能上还需要加入**防抖**，
  * 在代码上需要**优化组件间结构**与**组件生命周期结构**
  * 对于与后端交互需要在组件中加入watch，适时的对后端发起请求
* echarts5.x在vue中引入时需要用`import * as echarts from 'echarts'`